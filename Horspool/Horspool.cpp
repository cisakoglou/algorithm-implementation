/** 2056 - Χριστίνα Ισάκογλου
 *  christci@csd.auth.gr
 */

#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <cstdlib>
#include <cstdio>

using namespace std;

int main()
{
    string pattern,text;
    ifstream in;
    in.open("data.txt",ios::in);
    in>>pattern; // αγνοεί αρχικά κενά και αλλαγές γραμμής και την πρώτη συμβολοσειρά που βρίσκει τη χρησιμποιεί ως πρότυπο
    char c;
    while (in>>c) {  // όλους τους υπόλοιπους χαρακτήρες που βρίσκει τους τοποθετεί σε μια ενιαία συμβολοσειρά που αποτελεί
        text.push_back(c);   // το κείμενο μέσα στο οποίο θα ψάξει το πρότυπο που του ζητείται
    }
    in.close();
    cout<<"pattern: "<<pattern<<endl;
    cout<<"text: "<<text<<endl;
    // shiftTable
    // δημιουργία του πίνακα ολίσθησης χρησιμοποιώντας τη δομή map της stl
    // χρησιμοποιεί ως κλειδί τον κωδικό ASCII του εκάστοτε χαρακτήρα του δεκαεξαδικού συστήματος
    // και τον αντιστοιχίζει στον αριθμό βημάτων ολίσθησης που πρέπει να πραγματοποιηθεί όταν συναντώ το συγκεκριμένο χαρακτήρα
    // στο κείμενο μου και δεν έχω ταύτισι
    int patternSize = pattern.size();
    int textSize = text.size();
    map<int,int> shiftTable;
    int i;
    // αρχικά δηλώνω πως όταν συναντά οποιοδήποτε από τους 16 χαρακτήρες θα ολισθαίνει δεξιά τόσα βήματα όσα
    // και το μέγεθος του προτύπου
    for (i=48;i<=57;i++) {
        shiftTable[i]=patternSize;
    }
    for (i=65;i<=70;i++) {
        shiftTable[i]=patternSize;
    }
    int j;
    // στη συνέχεια αλλάζω τις τιμές στον πίνακα ολίσθησης μόνο για τους χαρακτήρες όπου υπάρχουν στο πρότυπο μου
    // έτσι ώστε αν συναντήσω στο κείμενο μου χαρακτήρα ο οποίος υπάρχει μεν στο πρότυπο αλλά δεν είναι σωστα στοιχισμένος
    // με το κείμενο, το πρότυπο να ολισθαίνει έτσι ώστε να να επιτευχτεί στοίχιση με τη δεξιότερη εμφάνιση του συγκεκριμένου
    // χαρακτήρα(για να μη χαθεί κανένα ταίριασμα)
    // ακόμη αγνοώ τον τελευταίο στα δεξιά αφού εφόσον αυτή είναι η μοναδική θέση στην οποία εμφανίζεται
    // η ολίσθηση υποχρεωτικά θα ισούται με το μήκος του προτύπου
    for (j=0;j<patternSize-1;j++) {
        shiftTable[pattern[j]] = patternSize-1-j;
    }
    cout<<"patternSize: "<<patternSize<<endl;
    cout<<"textSize: "<<textSize<<endl;
    // τυπώνει πίνακα ολίσθησης στη μορφή <χαρακτήρας - τιμή βημάτων ολίσθησης>
    char digit;
    map<int,int>::iterator ii;
    for (ii=shiftTable.begin();ii!=shiftTable.end();ii++) {
        digit = (*ii).first;
        cout<<digit<<" - "<<(*ii).second<<endl;

    }
    // horspool matching
    int w=patternSize-1; // δείκτης w ο οποίος θα στοιχίζει το τέλους του προτύπου με το κείμενο - δηλώνοντας
                         // δηλαδή το σημείο απο το οποίο θα ξεκινάν οι συγκρίσεις καθώς πραγματοποιούνται από τα δεξια προς τα αριστερά
    int k,comparisonsFail=0,comparisonsSuccess=0; // μετρλω ξεχωριστά τις πετυχημένες και τις αποτυχημένες συγκρίσεις
    bool flagFound=0; // μεταβλητή που αξιοποιείται στην περίπτωση που το πρότυπο δε βρεθεί στο κείμενο
    while (w<=textSize-1) { // οι ολισθήσεις-δοκιμές γίνονται από τα αριστερά προς τα δεξιά μέχρι να βρεθεί το τέλος του κειμένου
                            // να στοιχηθεί δηλαδή ο δείκτης w του προτύπου και με τον τελευταίο χαρακτήρα στα δεξια του κειμένου
        k=0;
        while ((k<=patternSize-1)&&(pattern[patternSize-1-k]==text[w-k])) {
            k++;comparisonsSuccess++;
        }
        if (k==patternSize) {
            cout<<"Brethike stis theseis: "<<w-patternSize+1<<" - "<<w<<" meta apo "<<comparisonsSuccess+comparisonsFail<<" sigkriseis"<<endl;
            flagFound=1;
            w=w+patternSize;
        }
        else {
            w=w+shiftTable[text[w]]; // ολισθαίνω δεξιά όσες θέσεις μου υποβάλλει ο πίνακας ολίσθησης
            comparisonsFail++; // από τη στιγμή που αναγκάζομαι να ολισθήσω δεξιά  συνεπάγεται ότι έχει γίνει μια αποχημένη σύκριση
        }
    }
    if (flagFound==0) cout<<"To protipo de vrethike"<<endl;
    cout<<"Sunolika oi sigkriseis pou eginan me Horspool htan: "<<comparisonsFail+comparisonsSuccess<<endl;
    // με τον αλγόριθμο ωμής βίας έχω αναγκαστικα μετά από κάθε αποτυχήμένη σύγκριση μια ολίσθηση δεξιά κατά ένα βήμα
    // άρα σίγουρα θα γίνουν (textSize-patternSize+1) δοκιμές
    // στη συνέχεια εξαρτάται από τη διαδοχή χαρακτήσων του κειμένου και του προτύπου η περίπτωση να γίνονται σε
    // κάθε δοκιμή (patternSize) συγκρίσεις, με αποτέλεσμα να φτάνουμε στη χειρότερη περίπτωση του αριθμού συγρκίσεων
    // που θα εμφανίζεται στο πρόγραμμα
    // για παράδειγμα η περίπτωση να έχω ενα κείμενο που αποτελείται μόνο απο μηδενικά
    // και ένα πρότυπο απο μηδενικά και στο τέλος 1 θα αποτελεί για τον αλγόριθμο ωμής βίας τη χειρότερη περίπτωση
    // ενώ αν το είναι βρίσκεται στην αρχή θα αποτελεί την καλύτερη
    // αντίθετα για τον αλγόριθμο horspool αυτά που θα ισχύουν με βάση τα παραπάνω δεδομένα θα είναι τα αντίστροφα
    cout<<"Me wmi via oi sugkriseis pou tha ginontan tha itan stin xeiroteri periptwsi: "<<patternSize*(textSize-patternSize+1)<<endl;
    return 0;
}
