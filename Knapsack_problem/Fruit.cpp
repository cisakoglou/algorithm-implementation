/** Χριστίνα Ισάκογλου - 2056	
  * christci@csd.auth.gr
  */

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <climits>

using namespace std;

int min (int x, int y); //συνάρτηση που επιστρέφει το μικρότερο αριθμό ανάμεσα από 2 ακεραίους

class Fruit //κλάση που περιέχει τις πληροφορίες για το φρούτο:όνομα, ποσότητα βιταμίνης που περιέχει και την ποσότητα στην οποία τελικά θα χορηγηθεί στον ασθενή
{
    public:
        char name;
        unsigned int quantity;
        int timesUsed;
        Fruit(char x,int y) {name=x;quantity=y;timesUsed=0;}

};

int main()
{
    vector<Fruit> availableFruits; // διαβάζοντας από το αρχείο εισάγω στο διάνυσμα αυτό όλα τα διαθέσιμα φρούτα
    unsigned int totalQuantity; // η συνολική ποσότητα βιταμίνης που πρέπει να χορηγηθεί στον ασθενή
    ifstream in;
    // -- διάβασμα από αρχείο
    in.open("fruits.txt",ios::in);
    in>>totalQuantity;

    char tempName;
    unsigned int tempQuantity;
    while (in>>tempName) {
        in>>tempQuantity;
        Fruit* tempFruit = new Fruit(tempName,tempQuantity);
        availableFruits.push_back(*tempFruit);
    }
    in.close();

    // -- υλοποίηση αλγορίθμου δυναμικού προγραμματισμού
    // δημιουργώ δισδιάστατο πίνακα [i,j] ο οποίος ουσιαστικά εκφράζει τη βέλτιστη λύση(μικρότερο συνδυασμό φρούτων) επιλέγοντας φρούτα από τα πρώτα i για τη 
    // χορήγηση ποσότητας j στον ασθενή.
    // σκοπός είναι η τιμή του κελιού[συνολικός αριθμός φρούτων,συνολική ποσότητα βιταμίνης που πρέπει να χορηγηθεί στον ασθενή] .
    // για την υλοποίηση τεχνικής δυναμικού προγραμματισμού αξιοποιώ το γεγονός ότι η ζητούμενη βέλτιστη λύση προκύπτει από τις βέλτιστες των υποπροβλημάτων,
    // αφού για παράδειγμα βρίσκοντας το συνδυασμό του μικρότερου πλήθους φρούτων για τη i γραμμή, προχωρώντας στη i+1 αξιοποιώ το δεδομένο που έχω και το βελτιώνω,
    // εφόσον μπορώ, με τη χρήση του νέου τύπου φρούτου της γραμμής. 
    // έτσι η προκύπτει και το χαρακτηριστικό της επικάλυψης των υποπροβλημάτων, δεδομένο που αξιοποιείται με την αποθήκευση των τιμών τους σε πίνακα, με σκοπό την
    // αποφυγή του επαναυπολογισμού τους
    // εφαρμόζω bottom-up τεχνική αφού με τη βοήθεια αναδρομικής εξίσωσης υπολογίζω πρώτα τις τιμές των υποπροβλημάτων 
    // τις οποίες αποθηκεύω στον πίνακα και οδηγούμαι στη λύση του βασικού μου προβλήματος
    unsigned int table[availableFruits.size()+1][totalQuantity+1];
    // 2 αρχικές συνθήκες 
    for (int j=1;j<=totalQuantity;j++) table[0][j] = INT_MAX;  // όταν δε χρησιμοποιείται κανένας τύπος φρούτου(δηλαδή βρίσκομαι στα κελιά της πρώτης γραμμής)
							       // χρησιμοποιώ ως τιμή αριθμού των φρούτων το μεγαλύτερο θετικό ακέραιο, ούτως ώστε ξεκινώντας από τη 
                                                               // χειρότερη περίπτωση να είμαι σε θέχη διαδοχικά να μειώνω αυτό τον αριθμό
    for (int i=0;i<=availableFruits.size();i++) table[i][0] = 0; // για χορήγηση μηδενικής ποσότητας βιταμίνης απαιτούνται 0 φρούτα
    // -- γεμίζω όλα τα κελιά του πίνακα με βάση την αναδρομικη
    /** αναδρομική εξίσωση : όταν j<d(i) table[i,j] = table[i-1,j], αλλιώς table[i,j] = min(table[i-1,j],1+table[i,j-d(i)]). (όπου d(i) η ποσότητα βιταμίνης
     * του φρούτου i)
     */
    for (int i=1;i<=availableFruits.size();i++) {
        for (int j=1;j<=totalQuantity;j++) {
	    // όταν η ποσότητα βιταμίνης που περιέχει το φρούτο είναι μεγαλύτερη από αυτόν της j, δηλαδή της εκάστοτε ποσότητα βιταμίνης χορήγησης που εξετάζεται,
            // δεν κάνω καμία σύγκριση για βελτίωση και απλώς τοποθετώ στο κελί τη βέλτιστη τιμή που βρήκα για το αμέσως προηγούμενο φρούτο(προηγούμενη γραμμή)
            if (availableFruits.at(i-1).quantity > j) table[i][j] = table [i-1][j];
	    // σε διαφορετική περίπτωση συγκρίνω δύο τιμές. Την τιμή που χρησιμοποιούσα πριν, θεωρώντας δηλαδή ότι δεν επιλέγω το φρούτο της γραμμής στην οποία βρίσκομαι
            // και την τιμή που εκφράζει το πλήθος των φρούτων όταν περιέχουν και το φρούτο που εξετάζω,για ποσότητα βιταμίνης όμως ίση με j-d(i), όπου j η στήλη στην
	    // οποία βρίσκομαι και d(i) η ποσότητα βιταμίνης που περιέχεται στο φρούτο(αξιοποιώ δηλαδή τη νέα βέλτιστη λύση που μου προσφέρει ο νέος τύπος φρούτου)
            else table[i][j] = min (table [i-1][j] , 1 + table [i][j-availableFruits.at(i-1).quantity]) ;
        }
    }
    // όταν το κελί που ζητώ να βρω και περιέχει το μικρότερο συνολικό αριθμό φρούτων καταλήγει να είναι ο μεγαλύτερος θετικός ακέραιος που έθεσα ως αρχική συνθήκη
    // σημαίνει ότι δεν μπορεί να σχηματιστεί κανένας κατάλληλος συνδυασμός φρούτων για τη συγκεκριμένη ποσότητα βιταμίνης
    // πχ όταν ζητείται να χορηγηθεί ποσότητα βιταμίνης μικρότερη και και από την μικρότερη ποσότητα βιταμίνης που περιέχεται σε φρούτο
    // (παρά το γεγονός ότι ο INT_MAX αναπαριστά αριθμό και όχι ακριβώς το άπειρο ο αριθμός αυτός δεν πρόκειται να μεταβληθεί καθ'όλη τη διάρκεια του προγράμματος
    // αφού ποτέ δε θα επιλέγεται από τη συνάρτηση min) 
    if (table [availableFruits.size()][totalQuantity] == INT_MAX) {
        cout << "Den uparxei lisi"<<endl; 
        return 1;                         

    }
    // -- βρίσκω ποια φρούτα χρησιμποιήθηκαν
    // ξεκινώντας από την κάτω δεξιά θέση του πίνακα προσπαθώ να καταλήξω στην πάνω αριστερή
    // διαδοχικά συγκρίνω την τιμή ενός κελιού με αυτήν του κελιού που βρίσκεται στην ίδια στήλη αλλά παραπάνω γραμμή κ.ο.κ
    // η μόνη περίπτωση που οδηγεί στην αλλαγή στήλης είναι όταν οι δύο αυτές τιμές διαφέρουν, κάτι που σημαίνει ότι το φρούτο της γραμμής στην οποία βρίσκομαι 
    // έχει επιλεγεί στον τελικό συνδυασμό φρούτων
    // τότε μετακινούμαι, χωρίς να αλλάζω γραμμή(αυτό χρησιμεύει στο να βρίσκω φρούτα τα οποία χρησιμοποιούνται παραπάνω από μία φορά),
    //  στη στήλη που αντιστοιχεί στην τιμή της στήλης που ήμουνα πλην της ποσότητας βιταμίνης του φρούτου που είδα πως 
    // υπάρχει στον τελικό συνδυασμό - αυτό χρησιμεύει στο να βρίσκω φρούτα τα οποία χρησιμοποιούνται παραπάνω από μία φορά
    int iPosition=availableFruits.size(),jPosition = totalQuantity;
    while (jPosition!=0) {
        if ( table[iPosition-1][jPosition] != table[iPosition][jPosition] ) {
            availableFruits.at(iPosition-1).timesUsed++;
            jPosition-=availableFruits.at(iPosition-1).quantity;
        }
        else {
            iPosition--;
        }
    }
    // -- εκτύπωση στην οθόνη
    cout <<"Mikroteros sinolikos arithmos froutwn : "<< table [availableFruits.size()][totalQuantity]<<endl;
    cout <<"Tupoi froutwn pou epilextikan : " << endl;
    for (int i=0;i<availableFruits.size();i++) {
	if (availableFruits.at(i).timesUsed != 0)
        	cout << ">> " << availableFruits.at(i).name << ", se posotita : " << availableFruits.at(i).timesUsed<<endl;
    }
    return 0;
}

int min (int x, int y)
{
    int min = (x<=y?x:y);
    return min;
}
